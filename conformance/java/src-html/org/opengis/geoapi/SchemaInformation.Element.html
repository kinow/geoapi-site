<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>Source code</title>
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../geoapi.css" title="Style">
</head>
<body>
<main role="main">
<div class="sourceContainer">
<pre><span class="sourceLineNo">001</span><a id="line.1">/*</a>
<span class="sourceLineNo">002</span><a id="line.2"> *    GeoAPI - Java interfaces for OGC/ISO standards</a>
<span class="sourceLineNo">003</span><a id="line.3"> *    http://www.geoapi.org</a>
<span class="sourceLineNo">004</span><a id="line.4"> *</a>
<span class="sourceLineNo">005</span><a id="line.5"> *    Copyright (C) 2018-2019 Open Geospatial Consortium, Inc.</a>
<span class="sourceLineNo">006</span><a id="line.6"> *    All Rights Reserved. http://www.opengeospatial.org/ogc/legal</a>
<span class="sourceLineNo">007</span><a id="line.7"> *</a>
<span class="sourceLineNo">008</span><a id="line.8"> *    Permission to use, copy, and modify this software and its documentation, with</a>
<span class="sourceLineNo">009</span><a id="line.9"> *    or without modification, for any purpose and without fee or royalty is hereby</a>
<span class="sourceLineNo">010</span><a id="line.10"> *    granted, provided that you include the following on ALL copies of the software</a>
<span class="sourceLineNo">011</span><a id="line.11"> *    and documentation or portions thereof, including modifications, that you make:</a>
<span class="sourceLineNo">012</span><a id="line.12"> *</a>
<span class="sourceLineNo">013</span><a id="line.13"> *    1. The full text of this NOTICE in a location viewable to users of the</a>
<span class="sourceLineNo">014</span><a id="line.14"> *       redistributed or derivative work.</a>
<span class="sourceLineNo">015</span><a id="line.15"> *    2. Notice of any changes or modifications to the OGC files, including the</a>
<span class="sourceLineNo">016</span><a id="line.16"> *       date changes were made.</a>
<span class="sourceLineNo">017</span><a id="line.17"> *</a>
<span class="sourceLineNo">018</span><a id="line.18"> *    THIS SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE</a>
<span class="sourceLineNo">019</span><a id="line.19"> *    NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED</a>
<span class="sourceLineNo">020</span><a id="line.20"> *    TO, WARRANTIES OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT</a>
<span class="sourceLineNo">021</span><a id="line.21"> *    THE USE OF THE SOFTWARE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY</a>
<span class="sourceLineNo">022</span><a id="line.22"> *    PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS.</a>
<span class="sourceLineNo">023</span><a id="line.23"> *</a>
<span class="sourceLineNo">024</span><a id="line.24"> *    COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR</a>
<span class="sourceLineNo">025</span><a id="line.25"> *    CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR DOCUMENTATION.</a>
<span class="sourceLineNo">026</span><a id="line.26"> *</a>
<span class="sourceLineNo">027</span><a id="line.27"> *    The name and trademarks of copyright holders may NOT be used in advertising or</a>
<span class="sourceLineNo">028</span><a id="line.28"> *    publicity pertaining to the software without specific, written prior permission.</a>
<span class="sourceLineNo">029</span><a id="line.29"> *    Title to copyright in this software and any associated documentation will at all</a>
<span class="sourceLineNo">030</span><a id="line.30"> *    times remain with copyright holders.</a>
<span class="sourceLineNo">031</span><a id="line.31"> */</a>
<span class="sourceLineNo">032</span><a id="line.32">package org.opengis.geoapi;</a>
<span class="sourceLineNo">033</span><a id="line.33"></a>
<span class="sourceLineNo">034</span><a id="line.34">import java.io.IOException;</a>
<span class="sourceLineNo">035</span><a id="line.35">import java.io.InputStream;</a>
<span class="sourceLineNo">036</span><a id="line.36">import java.net.URL;</a>
<span class="sourceLineNo">037</span><a id="line.37">import java.nio.file.Path;</a>
<span class="sourceLineNo">038</span><a id="line.38">import java.util.Map;</a>
<span class="sourceLineNo">039</span><a id="line.39">import java.util.Deque;</a>
<span class="sourceLineNo">040</span><a id="line.40">import java.util.HashMap;</a>
<span class="sourceLineNo">041</span><a id="line.41">import java.util.LinkedHashMap;</a>
<span class="sourceLineNo">042</span><a id="line.42">import java.util.ArrayDeque;</a>
<span class="sourceLineNo">043</span><a id="line.43">import java.util.Objects;</a>
<span class="sourceLineNo">044</span><a id="line.44">import javax.xml.XMLConstants;</a>
<span class="sourceLineNo">045</span><a id="line.45">import javax.xml.parsers.DocumentBuilderFactory;</a>
<span class="sourceLineNo">046</span><a id="line.46">import javax.xml.parsers.ParserConfigurationException;</a>
<span class="sourceLineNo">047</span><a id="line.47">import org.w3c.dom.Node;</a>
<span class="sourceLineNo">048</span><a id="line.48">import org.w3c.dom.Document;</a>
<span class="sourceLineNo">049</span><a id="line.49">import org.w3c.dom.NamedNodeMap;</a>
<span class="sourceLineNo">050</span><a id="line.50">import org.xml.sax.SAXException;</a>
<span class="sourceLineNo">051</span><a id="line.51">import org.opengis.annotation.UML;</a>
<span class="sourceLineNo">052</span><a id="line.52">import org.opengis.annotation.Classifier;</a>
<span class="sourceLineNo">053</span><a id="line.53">import org.opengis.annotation.Stereotype;</a>
<span class="sourceLineNo">054</span><a id="line.54"></a>
<span class="sourceLineNo">055</span><a id="line.55"></a>
<span class="sourceLineNo">056</span><a id="line.56">/**</a>
<span class="sourceLineNo">057</span><a id="line.57"> * Information about types and properties declared in OGC/ISO schemas. This class requires a connection</a>
<span class="sourceLineNo">058</span><a id="line.58"> * to &lt;a href="http://standards.iso.org/iso/19115/-3/"&gt;http://standards.iso.org/iso/19115/-3/&lt;/a&gt;</a>
<span class="sourceLineNo">059</span><a id="line.59"> * or a local copy of those files.</a>
<span class="sourceLineNo">060</span><a id="line.60"> *</a>
<span class="sourceLineNo">061</span><a id="line.61"> * &lt;p&gt;&lt;b&gt;Limitations:&lt;/b&gt;&lt;/p&gt;</a>
<span class="sourceLineNo">062</span><a id="line.62"> * Current implementation ignores the XML prefix (e.g. {@code "cit:"} in {@code "cit:CI_Citation"}).</a>
<span class="sourceLineNo">063</span><a id="line.63"> * We assume that there is no name collision, especially given that {@code "CI_"} prefix in front of</a>
<span class="sourceLineNo">064</span><a id="line.64"> * most OGC/ISO class names have the effect of a namespace. If a collision nevertheless happen, then</a>
<span class="sourceLineNo">065</span><a id="line.65"> * an exception will be thrown.</a>
<span class="sourceLineNo">066</span><a id="line.66"> *</a>
<span class="sourceLineNo">067</span><a id="line.67"> * &lt;p&gt;Current implementation assumes that XML element name, type name, property name and property type</a>
<span class="sourceLineNo">068</span><a id="line.68"> * name follow some naming convention. For example type names are suffixed with {@code "_Type"} in OGC</a>
<span class="sourceLineNo">069</span><a id="line.69"> * schemas, while property type names are suffixed with {@code "_PropertyType"}.  This class throws an</a>
<span class="sourceLineNo">070</span><a id="line.70"> * exception if a type does not follow the expected naming convention. This requirement makes</a>
<span class="sourceLineNo">071</span><a id="line.71"> * implementation easier, by reducing the amount of {@link Map}s that we need to manage.&lt;/p&gt;</a>
<span class="sourceLineNo">072</span><a id="line.72"> *</a>
<span class="sourceLineNo">073</span><a id="line.73"> * @author  Martin Desruisseaux (Geomatys)</a>
<span class="sourceLineNo">074</span><a id="line.74"> * @since   3.1</a>
<span class="sourceLineNo">075</span><a id="line.75"> * @version 3.1</a>
<span class="sourceLineNo">076</span><a id="line.76"> */</a>
<span class="sourceLineNo">077</span><a id="line.77">public class SchemaInformation {</a>
<span class="sourceLineNo">078</span><a id="line.78">    /**</a>
<span class="sourceLineNo">079</span><a id="line.79">     * The root of ISO schemas and namespaces, which is {@value}.</a>
<span class="sourceLineNo">080</span><a id="line.80">     */</a>
<span class="sourceLineNo">081</span><a id="line.81">    public static final String ROOT_NAMESPACE = "http://standards.iso.org/iso/";</a>
<span class="sourceLineNo">082</span><a id="line.82"></a>
<span class="sourceLineNo">083</span><a id="line.83">    /**</a>
<span class="sourceLineNo">084</span><a id="line.84">     * The prefix of XML type names for properties. In ISO/OGC schemas, this prefix does not appear</a>
<span class="sourceLineNo">085</span><a id="line.85">     * in the definition of class types but may appear in the definition of property types.</a>
<span class="sourceLineNo">086</span><a id="line.86">     */</a>
<span class="sourceLineNo">087</span><a id="line.87">    private static final String ABSTRACT_PREFIX = "Abstract_";</a>
<span class="sourceLineNo">088</span><a id="line.88"></a>
<span class="sourceLineNo">089</span><a id="line.89">    /**</a>
<span class="sourceLineNo">090</span><a id="line.90">     * The suffix of XML type names for classes.</a>
<span class="sourceLineNo">091</span><a id="line.91">     * This is used by convention in OGC/ISO standards (but not necessarily in other XSD).</a>
<span class="sourceLineNo">092</span><a id="line.92">     */</a>
<span class="sourceLineNo">093</span><a id="line.93">    private static final String TYPE_SUFFIX = "_Type";</a>
<span class="sourceLineNo">094</span><a id="line.94"></a>
<span class="sourceLineNo">095</span><a id="line.95">    /**</a>
<span class="sourceLineNo">096</span><a id="line.96">     * The suffix of XML property type names in a given class.</a>
<span class="sourceLineNo">097</span><a id="line.97">     * This is used by convention in OGC/ISO standards (but not necessarily in other XSD).</a>
<span class="sourceLineNo">098</span><a id="line.98">     */</a>
<span class="sourceLineNo">099</span><a id="line.99">    private static final String PROPERTY_TYPE_SUFFIX = "_PropertyType";</a>
<span class="sourceLineNo">100</span><a id="line.100"></a>
<span class="sourceLineNo">101</span><a id="line.101">    /**</a>
<span class="sourceLineNo">102</span><a id="line.102">     * XML type to ignore because of key collisions in {@link #typeDefinitions}.</a>
<span class="sourceLineNo">103</span><a id="line.103">     * Those collisions occur because code lists are defined as links to the same file,</a>
<span class="sourceLineNo">104</span><a id="line.104">     * with only different anchor positions.</a>
<span class="sourceLineNo">105</span><a id="line.105">     */</a>
<span class="sourceLineNo">106</span><a id="line.106">    private static final String CODELIST_TYPE = "gco:CodeListValue_Type";</a>
<span class="sourceLineNo">107</span><a id="line.107"></a>
<span class="sourceLineNo">108</span><a id="line.108">    /**</a>
<span class="sourceLineNo">109</span><a id="line.109">     * Separator between XML prefix and the actual name.</a>
<span class="sourceLineNo">110</span><a id="line.110">     */</a>
<span class="sourceLineNo">111</span><a id="line.111">    private static final char PREFIX_SEPARATOR = ':';</a>
<span class="sourceLineNo">112</span><a id="line.112"></a>
<span class="sourceLineNo">113</span><a id="line.113">    /**</a>
<span class="sourceLineNo">114</span><a id="line.114">     * If the computer contains a local copy of ISO schemas, path to that directory. Otherwise {@code null}.</a>
<span class="sourceLineNo">115</span><a id="line.115">     * If non-null, the {@value #ROOT_NAMESPACE} prefix in URL will be replaced by that path.</a>
<span class="sourceLineNo">116</span><a id="line.116">     * This field is usually {@code null}, but can be set to a non-null value for making tests faster.</a>
<span class="sourceLineNo">117</span><a id="line.117">     */</a>
<span class="sourceLineNo">118</span><a id="line.118">    private final Path schemaRootDirectory;</a>
<span class="sourceLineNo">119</span><a id="line.119"></a>
<span class="sourceLineNo">120</span><a id="line.120">    /**</a>
<span class="sourceLineNo">121</span><a id="line.121">     * A temporary buffer for miscellaneous string operations.</a>
<span class="sourceLineNo">122</span><a id="line.122">     * Valid only in a local scope since the content may change at any time.</a>
<span class="sourceLineNo">123</span><a id="line.123">     * For making this limitation clear, its length shall bet set to 0 after each usage.</a>
<span class="sourceLineNo">124</span><a id="line.124">     */</a>
<span class="sourceLineNo">125</span><a id="line.125">    private final StringBuilder buffer;</a>
<span class="sourceLineNo">126</span><a id="line.126"></a>
<span class="sourceLineNo">127</span><a id="line.127">    /**</a>
<span class="sourceLineNo">128</span><a id="line.128">     * The DOM factory used for reading XSD schemas.</a>
<span class="sourceLineNo">129</span><a id="line.129">     */</a>
<span class="sourceLineNo">130</span><a id="line.130">    private final DocumentBuilderFactory factory;</a>
<span class="sourceLineNo">131</span><a id="line.131"></a>
<span class="sourceLineNo">132</span><a id="line.132">    /**</a>
<span class="sourceLineNo">133</span><a id="line.133">     * URL of schemas loaded, for avoiding loading the same schema many time.</a>
<span class="sourceLineNo">134</span><a id="line.134">     * The last element on the queue is the schema in process of being loaded,</a>
<span class="sourceLineNo">135</span><a id="line.135">     * used for resolving relative paths in {@code &lt;xs:include&gt;} elements.</a>
<span class="sourceLineNo">136</span><a id="line.136">     */</a>
<span class="sourceLineNo">137</span><a id="line.137">    private final Deque&lt;String&gt; schemaLocations;</a>
<span class="sourceLineNo">138</span><a id="line.138"></a>
<span class="sourceLineNo">139</span><a id="line.139">    /**</a>
<span class="sourceLineNo">140</span><a id="line.140">     * The type and namespace of a property or type.</a>
<span class="sourceLineNo">141</span><a id="line.141">     */</a>
<span class="sourceLineNo">142</span><a id="line.142">    public static final class Element {</a>
<span class="sourceLineNo">143</span><a id="line.143">        /** The element type name.                   */ public final String  typeName;</a>
<span class="sourceLineNo">144</span><a id="line.144">        /** Element namespace as an URI.             */ public final String  namespace;</a>
<span class="sourceLineNo">145</span><a id="line.145">        /** Whether the property is mandatory.       */ public final boolean isRequired;</a>
<span class="sourceLineNo">146</span><a id="line.146">        /** Whether the property accepts many items. */ public final boolean isCollection;</a>
<span class="sourceLineNo">147</span><a id="line.147">        /** Documentation, or {@code null} if none.  */ public final String  documentation;</a>
<span class="sourceLineNo">148</span><a id="line.148"></a>
<span class="sourceLineNo">149</span><a id="line.149">        /** Stores information about a new property or type. */</a>
<span class="sourceLineNo">150</span><a id="line.150">        Element(final String typeName, final String namespace, final boolean isRequired, final boolean isCollection,</a>
<span class="sourceLineNo">151</span><a id="line.151">                final String  documentation)</a>
<span class="sourceLineNo">152</span><a id="line.152">        {</a>
<span class="sourceLineNo">153</span><a id="line.153">            this.typeName      = typeName;</a>
<span class="sourceLineNo">154</span><a id="line.154">            this.namespace     = namespace;</a>
<span class="sourceLineNo">155</span><a id="line.155">            this.isRequired    = isRequired;</a>
<span class="sourceLineNo">156</span><a id="line.156">            this.isCollection  = isCollection;</a>
<span class="sourceLineNo">157</span><a id="line.157">            this.documentation = documentation;</a>
<span class="sourceLineNo">158</span><a id="line.158">        }</a>
<span class="sourceLineNo">159</span><a id="line.159"></a>
<span class="sourceLineNo">160</span><a id="line.160">        /**</a>
<span class="sourceLineNo">161</span><a id="line.161">         * Returns the prefix if it can be derived from the {@linkplain #namespace}, or {@code null} otherwise.</a>
<span class="sourceLineNo">162</span><a id="line.162">         */</a>
<span class="sourceLineNo">163</span><a id="line.163">        String prefix() {</a>
<span class="sourceLineNo">164</span><a id="line.164">            if (namespace.startsWith(ROOT_NAMESPACE)) {</a>
<span class="sourceLineNo">165</span><a id="line.165">                final int end   = namespace.lastIndexOf('/', namespace.length() - 1);</a>
<span class="sourceLineNo">166</span><a id="line.166">                final int start = namespace.lastIndexOf('/', end - 1);</a>
<span class="sourceLineNo">167</span><a id="line.167">                return namespace.substring(start + 1, end);</a>
<span class="sourceLineNo">168</span><a id="line.168">            }</a>
<span class="sourceLineNo">169</span><a id="line.169">            return null;</a>
<span class="sourceLineNo">170</span><a id="line.170">        }</a>
<span class="sourceLineNo">171</span><a id="line.171"></a>
<span class="sourceLineNo">172</span><a id="line.172">        /**</a>
<span class="sourceLineNo">173</span><a id="line.173">         * Tests if this element has the same type name (including namespace) than given element.</a>
<span class="sourceLineNo">174</span><a id="line.174">         */</a>
<span class="sourceLineNo">175</span><a id="line.175">        boolean nameEqual(final Element other) {</a>
<span class="sourceLineNo">176</span><a id="line.176">            return Objects.equals(typeName,  other.typeName)</a>
<span class="sourceLineNo">177</span><a id="line.177">                &amp;&amp; Objects.equals(namespace, other.namespace);</a>
<span class="sourceLineNo">178</span><a id="line.178">        }</a>
<span class="sourceLineNo">179</span><a id="line.179"></a>
<span class="sourceLineNo">180</span><a id="line.180">        /**</a>
<span class="sourceLineNo">181</span><a id="line.181">         * Returns a string representation for debugging purpose.</a>
<span class="sourceLineNo">182</span><a id="line.182">         *</a>
<span class="sourceLineNo">183</span><a id="line.183">         * @return a string representation (may change in any future version).</a>
<span class="sourceLineNo">184</span><a id="line.184">         */</a>
<span class="sourceLineNo">185</span><a id="line.185">        @Override</a>
<span class="sourceLineNo">186</span><a id="line.186">        public String toString() {</a>
<span class="sourceLineNo">187</span><a id="line.187">            return typeName;</a>
<span class="sourceLineNo">188</span><a id="line.188">        }</a>
<span class="sourceLineNo">189</span><a id="line.189">    }</a>
<span class="sourceLineNo">190</span><a id="line.190"></a>
<span class="sourceLineNo">191</span><a id="line.191">    /**</a>
<span class="sourceLineNo">192</span><a id="line.192">     * Definitions of XML type for each class. In OGC/ISO schemas, those definitions have the {@value #TYPE_SUFFIX}</a>
<span class="sourceLineNo">193</span><a id="line.193">     * suffix in their name (which is omitted). The value is another map, where keys are property names and values</a>
<span class="sourceLineNo">194</span><a id="line.194">     * are their types, having the {@value #PROPERTY_TYPE_SUFFIX} suffix in their name (which is omitted).</a>
<span class="sourceLineNo">195</span><a id="line.195">     */</a>
<span class="sourceLineNo">196</span><a id="line.196">    private final Map&lt;String, Map&lt;String,Element&gt;&gt; typeDefinitions;</a>
<span class="sourceLineNo">197</span><a id="line.197"></a>
<span class="sourceLineNo">198</span><a id="line.198">    /**</a>
<span class="sourceLineNo">199</span><a id="line.199">     * Notifies that we are about to define the XML type for each property. In OGC/ISO schemas, those definitions</a>
<span class="sourceLineNo">200</span><a id="line.200">     * have the {@value #PROPERTY_TYPE_SUFFIX} suffix in their name (which is omitted). After this method call,</a>
<span class="sourceLineNo">201</span><a id="line.201">     * properties can be defined by calls to {@link #addProperty(String, String, boolean, boolean)}.</a>
<span class="sourceLineNo">202</span><a id="line.202">     */</a>
<span class="sourceLineNo">203</span><a id="line.203">    private void preparePropertyDefinitions(final String type) throws SchemaException {</a>
<span class="sourceLineNo">204</span><a id="line.204">        final String k = trim(type, TYPE_SUFFIX).intern();</a>
<span class="sourceLineNo">205</span><a id="line.205">        if ((currentProperties = typeDefinitions.get(k)) == null) {</a>
<span class="sourceLineNo">206</span><a id="line.206">            typeDefinitions.put(k, currentProperties = new LinkedHashMap&lt;&gt;());</a>
<span class="sourceLineNo">207</span><a id="line.207">        }</a>
<span class="sourceLineNo">208</span><a id="line.208">    }</a>
<span class="sourceLineNo">209</span><a id="line.209"></a>
<span class="sourceLineNo">210</span><a id="line.210">    /**</a>
<span class="sourceLineNo">211</span><a id="line.211">     * The properties of the XML type under examination, or {@code null} if none.</a>
<span class="sourceLineNo">212</span><a id="line.212">     * If non-null, this is one of the values in the {@link #typeDefinitions} map.</a>
<span class="sourceLineNo">213</span><a id="line.213">     * By convention, the {@code null} key is associated to information about the class.</a>
<span class="sourceLineNo">214</span><a id="line.214">     */</a>
<span class="sourceLineNo">215</span><a id="line.215">    private Map&lt;String,Element&gt; currentProperties;</a>
<span class="sourceLineNo">216</span><a id="line.216"></a>
<span class="sourceLineNo">217</span><a id="line.217">    /**</a>
<span class="sourceLineNo">218</span><a id="line.218">     * A single property type under examination, or {@code null} if none.</a>
<span class="sourceLineNo">219</span><a id="line.219">     * If non-null, this is a value ending with the {@value #PROPERTY_TYPE_SUFFIX} suffix.</a>
<span class="sourceLineNo">220</span><a id="line.220">     */</a>
<span class="sourceLineNo">221</span><a id="line.221">    private String currentPropertyType;</a>
<span class="sourceLineNo">222</span><a id="line.222"></a>
<span class="sourceLineNo">223</span><a id="line.223">    /**</a>
<span class="sourceLineNo">224</span><a id="line.224">     * Default value for the {@code required} attribute of {@link XmlElement}. This default value should</a>
<span class="sourceLineNo">225</span><a id="line.225">     * be {@code true} for properties declared inside a {@code &lt;sequence&gt;} element, and {@code false} for</a>
<span class="sourceLineNo">226</span><a id="line.226">     * properties declared inside a {@code &lt;choice&gt;} element.</a>
<span class="sourceLineNo">227</span><a id="line.227">     */</a>
<span class="sourceLineNo">228</span><a id="line.228">    private boolean requiredByDefault;</a>
<span class="sourceLineNo">229</span><a id="line.229"></a>
<span class="sourceLineNo">230</span><a id="line.230">    /**</a>
<span class="sourceLineNo">231</span><a id="line.231">     * Namespace of the type or properties being defined.</a>
<span class="sourceLineNo">232</span><a id="line.232">     * This is specified by {@code &lt;xs:schema targetNamespace="(…)"&gt;}.</a>
<span class="sourceLineNo">233</span><a id="line.233">     */</a>
<span class="sourceLineNo">234</span><a id="line.234">    private String targetNamespace;</a>
<span class="sourceLineNo">235</span><a id="line.235"></a>
<span class="sourceLineNo">236</span><a id="line.236">    /**</a>
<span class="sourceLineNo">237</span><a id="line.237">     * Expected departures between XML schemas and GeoAPI annotations.</a>
<span class="sourceLineNo">238</span><a id="line.238">     */</a>
<span class="sourceLineNo">239</span><a id="line.239">    private final Departures departures;</a>
<span class="sourceLineNo">240</span><a id="line.240"></a>
<span class="sourceLineNo">241</span><a id="line.241">    /**</a>
<span class="sourceLineNo">242</span><a id="line.242">     * Variant of the documentation to store (none, verbatim or sentences).</a>
<span class="sourceLineNo">243</span><a id="line.243">     */</a>
<span class="sourceLineNo">244</span><a id="line.244">    private final DocumentationStyle documentationStyle;</a>
<span class="sourceLineNo">245</span><a id="line.245"></a>
<span class="sourceLineNo">246</span><a id="line.246">    /**</a>
<span class="sourceLineNo">247</span><a id="line.247">     * Creates a new verifier. If the computer contains a local copy of ISO schemas, then the {@code schemaRootDirectory}</a>
<span class="sourceLineNo">248</span><a id="line.248">     * argument can be set to that directory for faster schema loadings. If non-null, that directory should contain the</a>
<span class="sourceLineNo">249</span><a id="line.249">     * same files than &lt;a href="http://standards.iso.org/iso/"&gt;http://standards.iso.org/iso/&lt;/a&gt; (not necessarily with all</a>
<span class="sourceLineNo">250</span><a id="line.250">     * sub-directories). In particular, that directory should contain an {@code 19115} sub-directory.</a>
<span class="sourceLineNo">251</span><a id="line.251">     *</a>
<span class="sourceLineNo">252</span><a id="line.252">     * &lt;p&gt;The {@link Departures#mergedTypes} entries will be {@linkplain Map#remove removed} as they are found.</a>
<span class="sourceLineNo">253</span><a id="line.253">     * This allows the caller to verify if the map contains any unnecessary departure declarations.&lt;/p&gt;</a>
<span class="sourceLineNo">254</span><a id="line.254">     *</a>
<span class="sourceLineNo">255</span><a id="line.255">     * @param schemaRootDirectory  path to local copy of ISO schemas, or {@code null} if none.</a>
<span class="sourceLineNo">256</span><a id="line.256">     * @param departures           expected departures between XML schemas and GeoAPI annotations.</a>
<span class="sourceLineNo">257</span><a id="line.257">     * @param style                style of the documentation to store (none, verbatim or sentences).</a>
<span class="sourceLineNo">258</span><a id="line.258">     */</a>
<span class="sourceLineNo">259</span><a id="line.259">    public SchemaInformation(final Path schemaRootDirectory, final Departures departures, final DocumentationStyle style) {</a>
<span class="sourceLineNo">260</span><a id="line.260">        this.schemaRootDirectory = schemaRootDirectory;</a>
<span class="sourceLineNo">261</span><a id="line.261">        this.departures          = departures;</a>
<span class="sourceLineNo">262</span><a id="line.262">        this.documentationStyle  = style;</a>
<span class="sourceLineNo">263</span><a id="line.263">        factory = DocumentBuilderFactory.newInstance();</a>
<span class="sourceLineNo">264</span><a id="line.264">        factory.setNamespaceAware(true);</a>
<span class="sourceLineNo">265</span><a id="line.265">        buffer = new StringBuilder(100);</a>
<span class="sourceLineNo">266</span><a id="line.266">        typeDefinitions = new HashMap&lt;&gt;();</a>
<span class="sourceLineNo">267</span><a id="line.267">        schemaLocations = new ArrayDeque&lt;&gt;();</a>
<span class="sourceLineNo">268</span><a id="line.268">    }</a>
<span class="sourceLineNo">269</span><a id="line.269"></a>
<span class="sourceLineNo">270</span><a id="line.270">    /**</a>
<span class="sourceLineNo">271</span><a id="line.271">     * Loads the default set of XSD files. This method invokes {@link #loadSchema(String)}</a>
<span class="sourceLineNo">272</span><a id="line.272">     * for a pre-defined set of metadata schemas, in approximate dependency order.</a>
<span class="sourceLineNo">273</span><a id="line.273">     *</a>
<span class="sourceLineNo">274</span><a id="line.274">     * @throws ParserConfigurationException if the XML parser can not be created.</a>
<span class="sourceLineNo">275</span><a id="line.275">     * @throws IOException     if an I/O error occurred while reading a file.</a>
<span class="sourceLineNo">276</span><a id="line.276">     * @throws SAXException    if a file can not be parsed as a XML document.</a>
<span class="sourceLineNo">277</span><a id="line.277">     * @throws SchemaException if a XML document can not be interpreted as an OGC/ISO schema.</a>
<span class="sourceLineNo">278</span><a id="line.278">     */</a>
<span class="sourceLineNo">279</span><a id="line.279">    public void loadDefaultSchemas() throws ParserConfigurationException, IOException, SAXException, SchemaException {</a>
<span class="sourceLineNo">280</span><a id="line.280">        for (final String p : new String[] {</a>
<span class="sourceLineNo">281</span><a id="line.281">//              "19115/-3/gco/1.0/gco.xsd",         // Geographic Common — defined in a different way than other modules</a>
<span class="sourceLineNo">282</span><a id="line.282">                "19115/-3/lan/1.0/lan.xsd",         // Language localization</a>
<span class="sourceLineNo">283</span><a id="line.283">                "19115/-3/mcc/1.0/mcc.xsd",         // Metadata Common Classes</a>
<span class="sourceLineNo">284</span><a id="line.284">                "19115/-3/gex/1.0/gex.xsd",         // Geospatial Extent</a>
<span class="sourceLineNo">285</span><a id="line.285">                "19115/-3/cit/1.0/cit.xsd",         // Citation and responsible party information</a>
<span class="sourceLineNo">286</span><a id="line.286">                "19115/-3/mmi/1.0/mmi.xsd",         // Metadata for maintenance information</a>
<span class="sourceLineNo">287</span><a id="line.287">                "19115/-3/mrd/1.0/mrd.xsd",         // Metadata for resource distribution</a>
<span class="sourceLineNo">288</span><a id="line.288">                "19115/-3/mdt/1.0/mdt.xsd",         // Metadata for data transfer</a>
<span class="sourceLineNo">289</span><a id="line.289">                "19115/-3/mco/1.0/mco.xsd",         // Metadata for constraints</a>
<span class="sourceLineNo">290</span><a id="line.290">                "19115/-3/mri/1.0/mri.xsd",         // Metadata for resource identification</a>
<span class="sourceLineNo">291</span><a id="line.291">                "19115/-3/srv/2.0/srv.xsd",         // Metadata for services</a>
<span class="sourceLineNo">292</span><a id="line.292">                "19115/-3/mac/1.0/mac.xsd",         // Metadata for acquisition</a>
<span class="sourceLineNo">293</span><a id="line.293">                "19115/-3/mrc/1.0/mrc.xsd",         // Metadata for resource content</a>
<span class="sourceLineNo">294</span><a id="line.294">                "19115/-3/mrl/1.0/mrl.xsd",         // Metadata for resource lineage</a>
<span class="sourceLineNo">295</span><a id="line.295">                "19157/-2/mdq/1.0/mdq.xsd",         // Metadata for data quality</a>
<span class="sourceLineNo">296</span><a id="line.296">                "19115/-3/mrs/1.0/mrs.xsd",         // Metadata for reference system</a>
<span class="sourceLineNo">297</span><a id="line.297">                "19115/-3/msr/1.0/msr.xsd",         // Metadata for spatial representation</a>
<span class="sourceLineNo">298</span><a id="line.298">                "19115/-3/mas/1.0/mas.xsd",         // Metadata for application schema</a>
<span class="sourceLineNo">299</span><a id="line.299">                "19115/-3/mex/1.0/mex.xsd",         // Metadata with schema extensions</a>
<span class="sourceLineNo">300</span><a id="line.300">                "19115/-3/mpc/1.0/mpc.xsd",         // Metadata for portrayal catalog</a>
<span class="sourceLineNo">301</span><a id="line.301">                "19115/-3/mdb/1.0/mdb.xsd"})        // Metadata base</a>
<span class="sourceLineNo">302</span><a id="line.302">        {</a>
<span class="sourceLineNo">303</span><a id="line.303">            loadSchema(ROOT_NAMESPACE + p);</a>
<span class="sourceLineNo">304</span><a id="line.304">        }</a>
<span class="sourceLineNo">305</span><a id="line.305">        /*</a>
<span class="sourceLineNo">306</span><a id="line.306">         * Hard-coded information from "19115/-3/gco/1.0/gco.xsd". We apply this workaround because current SchemaInformation</a>
<span class="sourceLineNo">307</span><a id="line.307">         * implementation can not parse most of gco.xsd file because it does not follow the usual pattern found in other files.</a>
<span class="sourceLineNo">308</span><a id="line.308">         */</a>
<span class="sourceLineNo">309</span><a id="line.309">        final String namespace = ROOT_NAMESPACE + "19115/-3/gco/1.0";</a>
<span class="sourceLineNo">310</span><a id="line.310">        addHardCoded("NameSpace",     namespace,</a>
<span class="sourceLineNo">311</span><a id="line.311">                     "isGlobal",      "Boolean",           Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">312</span><a id="line.312">                     "name",          "CharacterSequence", Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">313</span><a id="line.313"></a>
<span class="sourceLineNo">314</span><a id="line.314">        addHardCoded("GenericName",   namespace,</a>
<span class="sourceLineNo">315</span><a id="line.315">                     "scope",         "NameSpace",         Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">316</span><a id="line.316">                     "depth",         "Integer",           Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">317</span><a id="line.317">                     "parsedName",    "LocalName",         Boolean.TRUE, Boolean.TRUE);</a>
<span class="sourceLineNo">318</span><a id="line.318"></a>
<span class="sourceLineNo">319</span><a id="line.319">        addHardCoded("ScopedName",    namespace,</a>
<span class="sourceLineNo">320</span><a id="line.320">                     "head",          "LocalName",         Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">321</span><a id="line.321">                     "tail",          "GenericName",       Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">322</span><a id="line.322">                     "scopedName",    "CharacterSequence", Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">323</span><a id="line.323"></a>
<span class="sourceLineNo">324</span><a id="line.324">        addHardCoded("LocalName",     namespace,</a>
<span class="sourceLineNo">325</span><a id="line.325">                     "aName",         "CharacterSequence", Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">326</span><a id="line.326"></a>
<span class="sourceLineNo">327</span><a id="line.327">        addHardCoded("MemberName",    namespace,</a>
<span class="sourceLineNo">328</span><a id="line.328">                     "attributeType", "TypeName",          Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">329</span><a id="line.329">                     "aName",         "CharacterSequence", Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">330</span><a id="line.330"></a>
<span class="sourceLineNo">331</span><a id="line.331">        addHardCoded("RecordSchema",  namespace,</a>
<span class="sourceLineNo">332</span><a id="line.332">                     "schemaName",    "LocalName",         Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">333</span><a id="line.333">                     "description",   null,                Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">334</span><a id="line.334"></a>
<span class="sourceLineNo">335</span><a id="line.335">        addHardCoded("RecordType",    namespace,</a>
<span class="sourceLineNo">336</span><a id="line.336">                     "typeName",      "TypeName",          Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">337</span><a id="line.337">                     "schema",        "RecordSchema",      Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">338</span><a id="line.338">                     "memberTypes",   null,                Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">339</span><a id="line.339"></a>
<span class="sourceLineNo">340</span><a id="line.340">        addHardCoded("Record",        namespace,</a>
<span class="sourceLineNo">341</span><a id="line.341">                     "recordType",    "RecordType",        Boolean.TRUE, Boolean.FALSE,</a>
<span class="sourceLineNo">342</span><a id="line.342">                     "memberValue",   null,                Boolean.TRUE, Boolean.FALSE);</a>
<span class="sourceLineNo">343</span><a id="line.343">    }</a>
<span class="sourceLineNo">344</span><a id="line.344"></a>
<span class="sourceLineNo">345</span><a id="line.345">    /**</a>
<span class="sourceLineNo">346</span><a id="line.346">     * Adds a hard coded property. Used only for XSD file that we can not parse.</a>
<span class="sourceLineNo">347</span><a id="line.347">     *</a>
<span class="sourceLineNo">348</span><a id="line.348">     * @param  type        name of the type.</a>
<span class="sourceLineNo">349</span><a id="line.349">     * @param  namespace   namespace of all properties.</a>
<span class="sourceLineNo">350</span><a id="line.350">     * @param  properties  (property name, property type, isRequired, isCollection) tuples.</a>
<span class="sourceLineNo">351</span><a id="line.351">     */</a>
<span class="sourceLineNo">352</span><a id="line.352">    private void addHardCoded(final String type, final String namespace, final Object... properties) throws SchemaException {</a>
<span class="sourceLineNo">353</span><a id="line.353">        final Map&lt;String,Element&gt; pm = new LinkedHashMap&lt;&gt;(properties.length);</a>
<span class="sourceLineNo">354</span><a id="line.354">        for (int i=0; i&lt;properties.length;) {</a>
<span class="sourceLineNo">355</span><a id="line.355">            final String p = (String) properties[i++];</a>
<span class="sourceLineNo">356</span><a id="line.356">            if (pm.put(p, new Element((String) properties[i++], namespace, (Boolean) properties[i++], (Boolean) properties[i++], null)) != null) {</a>
<span class="sourceLineNo">357</span><a id="line.357">                throw new SchemaException(p);</a>
<span class="sourceLineNo">358</span><a id="line.358">            }</a>
<span class="sourceLineNo">359</span><a id="line.359">        }</a>
<span class="sourceLineNo">360</span><a id="line.360">        if (typeDefinitions.put(type, pm) != null) {</a>
<span class="sourceLineNo">361</span><a id="line.361">            throw new SchemaException(type);</a>
<span class="sourceLineNo">362</span><a id="line.362">        }</a>
<span class="sourceLineNo">363</span><a id="line.363">    }</a>
<span class="sourceLineNo">364</span><a id="line.364"></a>
<span class="sourceLineNo">365</span><a id="line.365">    /**</a>
<span class="sourceLineNo">366</span><a id="line.366">     * Loads the XSD file at the given URL.</a>
<span class="sourceLineNo">367</span><a id="line.367">     * Only information of interest are stored, and we assume that the XSD follows OGC/ISO conventions.</a>
<span class="sourceLineNo">368</span><a id="line.368">     * This method may be invoked recursively if the XSD contains {@code &lt;xs:include&gt;} elements.</a>
<span class="sourceLineNo">369</span><a id="line.369">     *</a>
<span class="sourceLineNo">370</span><a id="line.370">     * @param  location  complete URL to the XSD file to load.</a>
<span class="sourceLineNo">371</span><a id="line.371">     * @throws ParserConfigurationException if the XML parser can not be created.</a>
<span class="sourceLineNo">372</span><a id="line.372">     * @throws IOException     if an I/O error occurred while reading the specified file.</a>
<span class="sourceLineNo">373</span><a id="line.373">     * @throws SAXException    if the specified file can not be parsed as a XML document.</a>
<span class="sourceLineNo">374</span><a id="line.374">     * @throws SchemaException if the XML document can not be interpreted as an OGC/ISO schema.</a>
<span class="sourceLineNo">375</span><a id="line.375">     */</a>
<span class="sourceLineNo">376</span><a id="line.376">    public void loadSchema(String location)</a>
<span class="sourceLineNo">377</span><a id="line.377">            throws ParserConfigurationException, IOException, SAXException, SchemaException</a>
<span class="sourceLineNo">378</span><a id="line.378">    {</a>
<span class="sourceLineNo">379</span><a id="line.379">        if (schemaRootDirectory != null &amp;&amp; location.startsWith(ROOT_NAMESPACE)) {</a>
<span class="sourceLineNo">380</span><a id="line.380">            location = schemaRootDirectory.resolve(location.substring(ROOT_NAMESPACE.length())).toUri().toString();</a>
<span class="sourceLineNo">381</span><a id="line.381">        }</a>
<span class="sourceLineNo">382</span><a id="line.382">        if (!schemaLocations.contains(location)) {</a>
<span class="sourceLineNo">383</span><a id="line.383">            if (location.startsWith("http")) {</a>
<span class="sourceLineNo">384</span><a id="line.384">                info("Downloading " + location);</a>
<span class="sourceLineNo">385</span><a id="line.385">            }</a>
<span class="sourceLineNo">386</span><a id="line.386">            final Document doc;</a>
<span class="sourceLineNo">387</span><a id="line.387">            try (final InputStream in = new URL(location).openStream()) {</a>
<span class="sourceLineNo">388</span><a id="line.388">                doc = factory.newDocumentBuilder().parse(in);</a>
<span class="sourceLineNo">389</span><a id="line.389">            }</a>
<span class="sourceLineNo">390</span><a id="line.390">            schemaLocations.addLast(location);</a>
<span class="sourceLineNo">391</span><a id="line.391">            storeClassDefinition(doc);</a>
<span class="sourceLineNo">392</span><a id="line.392">        }</a>
<span class="sourceLineNo">393</span><a id="line.393">    }</a>
<span class="sourceLineNo">394</span><a id="line.394"></a>
<span class="sourceLineNo">395</span><a id="line.395">    /**</a>
<span class="sourceLineNo">396</span><a id="line.396">     * Stores information about classes in the given node and children. This method invokes itself</a>
<span class="sourceLineNo">397</span><a id="line.397">     * for scanning children, until we reach sub-nodes about properties (in which case we continue</a>
<span class="sourceLineNo">398</span><a id="line.398">     * with {@link #storePropertyDefinition(Node)}).</a>
<span class="sourceLineNo">399</span><a id="line.399">     */</a>
<span class="sourceLineNo">400</span><a id="line.400">    private void storeClassDefinition(final Node node)</a>
<span class="sourceLineNo">401</span><a id="line.401">            throws IOException, ParserConfigurationException, SAXException, SchemaException</a>
<span class="sourceLineNo">402</span><a id="line.402">    {</a>
<span class="sourceLineNo">403</span><a id="line.403">        if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(node.getNamespaceURI())) {</a>
<span class="sourceLineNo">404</span><a id="line.404">            switch (node.getLocalName()) {</a>
<span class="sourceLineNo">405</span><a id="line.405">                case "schema": {</a>
<span class="sourceLineNo">406</span><a id="line.406">                    targetNamespace = getMandatoryAttribute(node, "targetNamespace").intern();</a>
<span class="sourceLineNo">407</span><a id="line.407">                    break;</a>
<span class="sourceLineNo">408</span><a id="line.408">                }</a>
<span class="sourceLineNo">409</span><a id="line.409">                /*</a>
<span class="sourceLineNo">410</span><a id="line.410">                 * &lt;xs:include schemaLocation="(…).xsd"&gt;</a>
<span class="sourceLineNo">411</span><a id="line.411">                 * Load the schema at the given URL, which is assumed relative.</a>
<span class="sourceLineNo">412</span><a id="line.412">                 */</a>
<span class="sourceLineNo">413</span><a id="line.413">                case "include": {</a>
<span class="sourceLineNo">414</span><a id="line.414">                    final String oldTarget = targetNamespace;</a>
<span class="sourceLineNo">415</span><a id="line.415">                    final String location = schemaLocations.getLast();</a>
<span class="sourceLineNo">416</span><a id="line.416">                    final String path = buffer.append(location, 0, location.lastIndexOf('/') + 1)</a>
<span class="sourceLineNo">417</span><a id="line.417">                            .append(getMandatoryAttribute(node, "schemaLocation")).toString();</a>
<span class="sourceLineNo">418</span><a id="line.418">                    buffer.setLength(0);</a>
<span class="sourceLineNo">419</span><a id="line.419">                    loadSchema(path);</a>
<span class="sourceLineNo">420</span><a id="line.420">                    targetNamespace = oldTarget;</a>
<span class="sourceLineNo">421</span><a id="line.421">                    return;                             // Skip children (normally, there is none).</a>
<span class="sourceLineNo">422</span><a id="line.422">                }</a>
<span class="sourceLineNo">423</span><a id="line.423">                /*</a>
<span class="sourceLineNo">424</span><a id="line.424">                 * &lt;xs:element name="(…)" type="(…)_Type"&gt;</a>
<span class="sourceLineNo">425</span><a id="line.425">                 * Verify that the names comply with our assumptions.</a>
<span class="sourceLineNo">426</span><a id="line.426">                 */</a>
<span class="sourceLineNo">427</span><a id="line.427">                case "element": {</a>
<span class="sourceLineNo">428</span><a id="line.428">                    final String name = getMandatoryAttribute(node, "name");</a>
<span class="sourceLineNo">429</span><a id="line.429">                    final String type = getMandatoryAttribute(node, "type");</a>
<span class="sourceLineNo">430</span><a id="line.430">                    final String doc  = documentation(node);</a>
<span class="sourceLineNo">431</span><a id="line.431">                    if (CODELIST_TYPE.equals(type)) {</a>
<span class="sourceLineNo">432</span><a id="line.432">                        final Map&lt;String,Element&gt; properties = new HashMap&lt;&gt;(4);</a>
<span class="sourceLineNo">433</span><a id="line.433">                        final Element info = new Element(null, targetNamespace, false, false, doc);</a>
<span class="sourceLineNo">434</span><a id="line.434">                        properties.put(null, info);     // Remember namespace of the code list.</a>
<span class="sourceLineNo">435</span><a id="line.435">                        properties.put(name, info);     // Pseudo-property used in our CodeList adapters.</a>
<span class="sourceLineNo">436</span><a id="line.436">                        if (typeDefinitions.put(name, properties) != null) {</a>
<span class="sourceLineNo">437</span><a id="line.437">                            throw new SchemaException(String.format("Code list \"%s\" is defined twice.", name));</a>
<span class="sourceLineNo">438</span><a id="line.438">                        }</a>
<span class="sourceLineNo">439</span><a id="line.439">                    } else {</a>
<span class="sourceLineNo">440</span><a id="line.440">                        /*</a>
<span class="sourceLineNo">441</span><a id="line.441">                         * Any type other than code list. Call `addProperty(null, …)` with null as a sentinel value</a>
<span class="sourceLineNo">442</span><a id="line.442">                         * for class definition. Properties will be added later when reading the `complexType` block.</a>
<span class="sourceLineNo">443</span><a id="line.443">                         */</a>
<span class="sourceLineNo">444</span><a id="line.444">                        verifyNamingConvention(schemaLocations.getLast(), name, type, TYPE_SUFFIX);</a>
<span class="sourceLineNo">445</span><a id="line.445">                        preparePropertyDefinitions(type);</a>
<span class="sourceLineNo">446</span><a id="line.446">                        addProperty(null, type, false, false, doc);</a>
<span class="sourceLineNo">447</span><a id="line.447">                        currentProperties = null;</a>
<span class="sourceLineNo">448</span><a id="line.448">                    }</a>
<span class="sourceLineNo">449</span><a id="line.449">                    return;                             // Ignore children (they are about documentation).</a>
<span class="sourceLineNo">450</span><a id="line.450">                }</a>
<span class="sourceLineNo">451</span><a id="line.451">                /*</a>
<span class="sourceLineNo">452</span><a id="line.452">                 * &lt;xs:complexType name="(…)_Type"&gt;</a>
<span class="sourceLineNo">453</span><a id="line.453">                 * &lt;xs:complexType name="(…)_PropertyType"&gt;</a>
<span class="sourceLineNo">454</span><a id="line.454">                 */</a>
<span class="sourceLineNo">455</span><a id="line.455">                case "complexType": {</a>
<span class="sourceLineNo">456</span><a id="line.456">                    String name = getMandatoryAttribute(node, "name");</a>
<span class="sourceLineNo">457</span><a id="line.457">                    if (name.endsWith(PROPERTY_TYPE_SUFFIX)) {</a>
<span class="sourceLineNo">458</span><a id="line.458">                        currentPropertyType = name;</a>
<span class="sourceLineNo">459</span><a id="line.459">                        verifyPropertyType(node);</a>
<span class="sourceLineNo">460</span><a id="line.460">                        currentPropertyType = null;</a>
<span class="sourceLineNo">461</span><a id="line.461">                    } else {</a>
<span class="sourceLineNo">462</span><a id="line.462">                        /*</a>
<span class="sourceLineNo">463</span><a id="line.463">                         * In the case of "(…)_Type", we will replace some ISO 19115-2 types by ISO 19115-1 types.</a>
<span class="sourceLineNo">464</span><a id="line.464">                         * For example "MI_Band_Type" is renamed as "MD_Band_Type". We do that because we use only</a>
<span class="sourceLineNo">465</span><a id="line.465">                         * one class for representing those two distinct ISO types. Note that not all ISO 19115-2</a>
<span class="sourceLineNo">466</span><a id="line.466">                         * types extend an ISO 19115-1 type, so we need to apply a case-by-case approach.</a>
<span class="sourceLineNo">467</span><a id="line.467">                         */</a>
<span class="sourceLineNo">468</span><a id="line.468">                        requiredByDefault = true;</a>
<span class="sourceLineNo">469</span><a id="line.469">                        final Departures.MergeInfo info = departures.nameOfMergedType(name);</a>
<span class="sourceLineNo">470</span><a id="line.470">                        preparePropertyDefinitions(info.typeName);</a>
<span class="sourceLineNo">471</span><a id="line.471">                        info.beforeAddProperties(currentProperties);</a>
<span class="sourceLineNo">472</span><a id="line.472">                        storePropertyDefinition(node);</a>
<span class="sourceLineNo">473</span><a id="line.473">                        info.afterAddProperties(currentProperties);</a>
<span class="sourceLineNo">474</span><a id="line.474">                        currentProperties = null;</a>
<span class="sourceLineNo">475</span><a id="line.475">                    }</a>
<span class="sourceLineNo">476</span><a id="line.476">                    return;                             // Skip children since they have already been examined.</a>
<span class="sourceLineNo">477</span><a id="line.477">                }</a>
<span class="sourceLineNo">478</span><a id="line.478">            }</a>
<span class="sourceLineNo">479</span><a id="line.479">        }</a>
<span class="sourceLineNo">480</span><a id="line.480">        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {</a>
<span class="sourceLineNo">481</span><a id="line.481">            storeClassDefinition(child);</a>
<span class="sourceLineNo">482</span><a id="line.482">        }</a>
<span class="sourceLineNo">483</span><a id="line.483">    }</a>
<span class="sourceLineNo">484</span><a id="line.484"></a>
<span class="sourceLineNo">485</span><a id="line.485">    /**</a>
<span class="sourceLineNo">486</span><a id="line.486">     * Stores information about properties in the current class. The {@link #currentProperties} field must be</a>
<span class="sourceLineNo">487</span><a id="line.487">     * set to the map of properties for the class defined by the enclosing {@code &lt;xs:complexType&gt;} element.</a>
<span class="sourceLineNo">488</span><a id="line.488">     * This method parses elements of the following form:</a>
<span class="sourceLineNo">489</span><a id="line.489">     *</a>
<span class="sourceLineNo">490</span><a id="line.490">     * {@preformat xml</a>
<span class="sourceLineNo">491</span><a id="line.491">     *   &lt;xs:element name="(…)" type="(…)_PropertyType" minOccurs="(…)" maxOccurs="(…)"&gt;</a>
<span class="sourceLineNo">492</span><a id="line.492">     * }</a>
<span class="sourceLineNo">493</span><a id="line.493">     */</a>
<span class="sourceLineNo">494</span><a id="line.494">    private void storePropertyDefinition(final Node node) throws SchemaException {</a>
<span class="sourceLineNo">495</span><a id="line.495">        if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(node.getNamespaceURI())) {</a>
<span class="sourceLineNo">496</span><a id="line.496">            switch (node.getLocalName()) {</a>
<span class="sourceLineNo">497</span><a id="line.497">                case "sequence": {</a>
<span class="sourceLineNo">498</span><a id="line.498">                    requiredByDefault = true;</a>
<span class="sourceLineNo">499</span><a id="line.499">                    break;</a>
<span class="sourceLineNo">500</span><a id="line.500">                }</a>
<span class="sourceLineNo">501</span><a id="line.501">                case "choice": {</a>
<span class="sourceLineNo">502</span><a id="line.502">                    requiredByDefault = false;</a>
<span class="sourceLineNo">503</span><a id="line.503">                    break;</a>
<span class="sourceLineNo">504</span><a id="line.504">                }</a>
<span class="sourceLineNo">505</span><a id="line.505">                case "element": {</a>
<span class="sourceLineNo">506</span><a id="line.506">                    boolean isRequired = requiredByDefault;</a>
<span class="sourceLineNo">507</span><a id="line.507">                    boolean isCollection = false;</a>
<span class="sourceLineNo">508</span><a id="line.508">                    final NamedNodeMap attributes = node.getAttributes();</a>
<span class="sourceLineNo">509</span><a id="line.509">                    if (attributes != null) {</a>
<span class="sourceLineNo">510</span><a id="line.510">                        Node attr = attributes.getNamedItem("minOccurs");</a>
<span class="sourceLineNo">511</span><a id="line.511">                        if (attr != null) {</a>
<span class="sourceLineNo">512</span><a id="line.512">                            final String value = attr.getNodeValue();</a>
<span class="sourceLineNo">513</span><a id="line.513">                            if (value != null) {</a>
<span class="sourceLineNo">514</span><a id="line.514">                                isRequired = Integer.parseInt(value) &gt; 0;</a>
<span class="sourceLineNo">515</span><a id="line.515">                            }</a>
<span class="sourceLineNo">516</span><a id="line.516">                        }</a>
<span class="sourceLineNo">517</span><a id="line.517">                        attr = attributes.getNamedItem("maxOccurs");</a>
<span class="sourceLineNo">518</span><a id="line.518">                        if (attr != null) {</a>
<span class="sourceLineNo">519</span><a id="line.519">                            final String value = attr.getNodeValue();</a>
<span class="sourceLineNo">520</span><a id="line.520">                            if (value != null) {</a>
<span class="sourceLineNo">521</span><a id="line.521">                                isCollection = value.equals("unbounded") || Integer.parseInt(value) &gt;  1;</a>
<span class="sourceLineNo">522</span><a id="line.522">                            }</a>
<span class="sourceLineNo">523</span><a id="line.523">                        }</a>
<span class="sourceLineNo">524</span><a id="line.524">                    }</a>
<span class="sourceLineNo">525</span><a id="line.525">                    addProperty(getMandatoryAttribute(node, "name").intern(),</a>
<span class="sourceLineNo">526</span><a id="line.526">                           trim(getMandatoryAttribute(node, "type"), PROPERTY_TYPE_SUFFIX).intern(),</a>
<span class="sourceLineNo">527</span><a id="line.527">                           isRequired, isCollection, documentation(node));</a>
<span class="sourceLineNo">528</span><a id="line.528">                    return;</a>
<span class="sourceLineNo">529</span><a id="line.529">                }</a>
<span class="sourceLineNo">530</span><a id="line.530">            }</a>
<span class="sourceLineNo">531</span><a id="line.531">        }</a>
<span class="sourceLineNo">532</span><a id="line.532">        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {</a>
<span class="sourceLineNo">533</span><a id="line.533">            storePropertyDefinition(child);</a>
<span class="sourceLineNo">534</span><a id="line.534">        }</a>
<span class="sourceLineNo">535</span><a id="line.535">    }</a>
<span class="sourceLineNo">536</span><a id="line.536"></a>
<span class="sourceLineNo">537</span><a id="line.537">    /**</a>
<span class="sourceLineNo">538</span><a id="line.538">     * Verifies the naming convention of property defined by the given node. The {@link #currentPropertyType}</a>
<span class="sourceLineNo">539</span><a id="line.539">     * field must be set to the type of the property defined by the enclosing {@code &lt;xs:complexType&gt;} element.</a>
<span class="sourceLineNo">540</span><a id="line.540">     * This method parses elements of the following form:</a>
<span class="sourceLineNo">541</span><a id="line.541">     *</a>
<span class="sourceLineNo">542</span><a id="line.542">     * {@preformat xml</a>
<span class="sourceLineNo">543</span><a id="line.543">     *   &lt;xs:element ref="(…)"&gt;</a>
<span class="sourceLineNo">544</span><a id="line.544">     * }</a>
<span class="sourceLineNo">545</span><a id="line.545">     */</a>
<span class="sourceLineNo">546</span><a id="line.546">    private void verifyPropertyType(final Node node) throws SchemaException {</a>
<span class="sourceLineNo">547</span><a id="line.547">        if (XMLConstants.W3C_XML_SCHEMA_NS_URI.equals(node.getNamespaceURI())) {</a>
<span class="sourceLineNo">548</span><a id="line.548">            switch (node.getLocalName()) {</a>
<span class="sourceLineNo">549</span><a id="line.549">                case "element": {</a>
<span class="sourceLineNo">550</span><a id="line.550">                    verifyNamingConvention(schemaLocations.getLast(),</a>
<span class="sourceLineNo">551</span><a id="line.551">                            getMandatoryAttribute(node, "ref"), currentPropertyType, PROPERTY_TYPE_SUFFIX);</a>
<span class="sourceLineNo">552</span><a id="line.552">                    return;</a>
<span class="sourceLineNo">553</span><a id="line.553">                }</a>
<span class="sourceLineNo">554</span><a id="line.554">                case "choice": {</a>
<span class="sourceLineNo">555</span><a id="line.555">                    /*</a>
<span class="sourceLineNo">556</span><a id="line.556">                     * &lt;xs:choice&gt; is used for unions. In those case, many &lt;xs:element&gt; are expected,</a>
<span class="sourceLineNo">557</span><a id="line.557">                     * and none of them may have the union name. So we have to stop verification here.</a>
<span class="sourceLineNo">558</span><a id="line.558">                     */</a>
<span class="sourceLineNo">559</span><a id="line.559">                    return;</a>
<span class="sourceLineNo">560</span><a id="line.560">                }</a>
<span class="sourceLineNo">561</span><a id="line.561">            }</a>
<span class="sourceLineNo">562</span><a id="line.562">        }</a>
<span class="sourceLineNo">563</span><a id="line.563">        for (Node child = node.getFirstChild(); child != null; child = child.getNextSibling()) {</a>
<span class="sourceLineNo">564</span><a id="line.564">            verifyPropertyType(child);</a>
<span class="sourceLineNo">565</span><a id="line.565">        }</a>
<span class="sourceLineNo">566</span><a id="line.566">    }</a>
<span class="sourceLineNo">567</span><a id="line.567"></a>
<span class="sourceLineNo">568</span><a id="line.568">    /**</a>
<span class="sourceLineNo">569</span><a id="line.569">     * Verifies that the relationship between the name of the given entity and its type are consistent with</a>
<span class="sourceLineNo">570</span><a id="line.570">     * OGC/ISO conventions. This method ignores the prefix (e.g. {@code "mdb:"} in {@code "mdb:MD_Metadata"}).</a>
<span class="sourceLineNo">571</span><a id="line.571">     *</a>
<span class="sourceLineNo">572</span><a id="line.572">     * @param  enclosing  schema or other container where the error happened.</a>
<span class="sourceLineNo">573</span><a id="line.573">     * @param  name       the class or property name. Example: {@code "MD_Metadata"}, {@code "citation"}.</a>
<span class="sourceLineNo">574</span><a id="line.574">     * @param  type       the type of the above named object. Example: {@code "MD_Metadata_Type"}, {@code "CI_Citation_PropertyType"}.</a>
<span class="sourceLineNo">575</span><a id="line.575">     * @param  suffix     the expected suffix at the end of {@code type}.</a>
<span class="sourceLineNo">576</span><a id="line.576">     * @throws SchemaException if the given {@code name} and {@code type} are not compliant with expected convention.</a>
<span class="sourceLineNo">577</span><a id="line.577">     */</a>
<span class="sourceLineNo">578</span><a id="line.578">    private static void verifyNamingConvention(final String enclosing,</a>
<span class="sourceLineNo">579</span><a id="line.579">            final String name, final String type, final String suffix) throws SchemaException</a>
<span class="sourceLineNo">580</span><a id="line.580">    {</a>
<span class="sourceLineNo">581</span><a id="line.581">        if (type.endsWith(suffix)) {</a>
<span class="sourceLineNo">582</span><a id="line.582">            int nameStart = name.indexOf(PREFIX_SEPARATOR) + 1;        // Skip "mdb:" or similar prefix.</a>
<span class="sourceLineNo">583</span><a id="line.583">            int typeStart = type.indexOf(PREFIX_SEPARATOR) + 1;</a>
<span class="sourceLineNo">584</span><a id="line.584">            final int plg = ABSTRACT_PREFIX.length();</a>
<span class="sourceLineNo">585</span><a id="line.585">            if (name.regionMatches(nameStart, ABSTRACT_PREFIX, 0, plg)) nameStart += plg;</a>
<span class="sourceLineNo">586</span><a id="line.586">            if (type.regionMatches(typeStart, ABSTRACT_PREFIX, 0, plg)) typeStart += plg;</a>
<span class="sourceLineNo">587</span><a id="line.587">            final int length = name.length() - nameStart;</a>
<span class="sourceLineNo">588</span><a id="line.588">            if (type.length() - typeStart - suffix.length() == length &amp;&amp;</a>
<span class="sourceLineNo">589</span><a id="line.589">                    type.regionMatches(typeStart, name, nameStart, length))</a>
<span class="sourceLineNo">590</span><a id="line.590">            {</a>
<span class="sourceLineNo">591</span><a id="line.591">                return;</a>
<span class="sourceLineNo">592</span><a id="line.592">            }</a>
<span class="sourceLineNo">593</span><a id="line.593">        }</a>
<span class="sourceLineNo">594</span><a id="line.594">        throw new SchemaException(String.format("Error in %s:%n" +</a>
<span class="sourceLineNo">595</span><a id="line.595">                "The type name should be the name with \"%s\" suffix, but found name=\"%s\" and type=\"%s\"&gt;.",</a>
<span class="sourceLineNo">596</span><a id="line.596">                enclosing, suffix, name, type));</a>
<span class="sourceLineNo">597</span><a id="line.597">    }</a>
<span class="sourceLineNo">598</span><a id="line.598"></a>
<span class="sourceLineNo">599</span><a id="line.599">    /**</a>
<span class="sourceLineNo">600</span><a id="line.600">     * Adds a property of the current name and type. This method is invoked during schema parsing.</a>
<span class="sourceLineNo">601</span><a id="line.601">     * The property namespace is assumed to be {@link #targetNamespace}.</a>
<span class="sourceLineNo">602</span><a id="line.602">     */</a>
<span class="sourceLineNo">603</span><a id="line.603">    private void addProperty(final String name, final String type, final boolean isRequired, final boolean isCollection,</a>
<span class="sourceLineNo">604</span><a id="line.604">            final String documentation) throws SchemaException</a>
<span class="sourceLineNo">605</span><a id="line.605">    {</a>
<span class="sourceLineNo">606</span><a id="line.606">        final Element info = new Element(type, targetNamespace, isRequired, isCollection, documentation);</a>
<span class="sourceLineNo">607</span><a id="line.607">        final Element old = currentProperties.put(name, info);</a>
<span class="sourceLineNo">608</span><a id="line.608">        if (old != null &amp;&amp; !old.nameEqual(info)) {</a>
<span class="sourceLineNo">609</span><a id="line.609">            throw new SchemaException(String.format("Error while parsing %s:%n" +</a>
<span class="sourceLineNo">610</span><a id="line.610">                    "Property \"%s\" is associated to type \"%s\", but that property was already associated to \"%s\".",</a>
<span class="sourceLineNo">611</span><a id="line.611">                    schemaLocations.getLast(), name, type, old));</a>
<span class="sourceLineNo">612</span><a id="line.612">        }</a>
<span class="sourceLineNo">613</span><a id="line.613">    }</a>
<span class="sourceLineNo">614</span><a id="line.614"></a>
<span class="sourceLineNo">615</span><a id="line.615">    /**</a>
<span class="sourceLineNo">616</span><a id="line.616">     * Returns the documentation for the given node, with the first letter made upper case</a>
<span class="sourceLineNo">617</span><a id="line.617">     * and a dot added at the end of the sentence. Null or empty texts are ignored.</a>
<span class="sourceLineNo">618</span><a id="line.618">     */</a>
<span class="sourceLineNo">619</span><a id="line.619">    private String documentation(Node node) {</a>
<span class="sourceLineNo">620</span><a id="line.620">        if (documentationStyle != DocumentationStyle.NONE) {</a>
<span class="sourceLineNo">621</span><a id="line.621">            node = node.getFirstChild();</a>
<span class="sourceLineNo">622</span><a id="line.622">            while (node != null) {</a>
<span class="sourceLineNo">623</span><a id="line.623">                final String name = node.getLocalName();</a>
<span class="sourceLineNo">624</span><a id="line.624">                if (name != null) switch (name) {</a>
<span class="sourceLineNo">625</span><a id="line.625">                    case "annotation": {</a>
<span class="sourceLineNo">626</span><a id="line.626">                        node = node.getFirstChild();        // Expect "documentation" as a child of "annotation".</a>
<span class="sourceLineNo">627</span><a id="line.627">                        continue;</a>
<span class="sourceLineNo">628</span><a id="line.628">                    }</a>
<span class="sourceLineNo">629</span><a id="line.629">                    case "documentation": {</a>
<span class="sourceLineNo">630</span><a id="line.630">                        String doc = node.getTextContent();</a>
<span class="sourceLineNo">631</span><a id="line.631">                        if (doc != null &amp;&amp; documentationStyle == DocumentationStyle.SENTENCE) {</a>
<span class="sourceLineNo">632</span><a id="line.632">                            doc = DocumentationStyle.sentence(doc, buffer);</a>
<span class="sourceLineNo">633</span><a id="line.633">                            buffer.setLength(0);</a>
<span class="sourceLineNo">634</span><a id="line.634">                        }</a>
<span class="sourceLineNo">635</span><a id="line.635">                        return doc;</a>
<span class="sourceLineNo">636</span><a id="line.636">                    }</a>
<span class="sourceLineNo">637</span><a id="line.637">                }</a>
<span class="sourceLineNo">638</span><a id="line.638">                node = node.getNextSibling();</a>
<span class="sourceLineNo">639</span><a id="line.639">            }</a>
<span class="sourceLineNo">640</span><a id="line.640">        }</a>
<span class="sourceLineNo">641</span><a id="line.641">        return null;</a>
<span class="sourceLineNo">642</span><a id="line.642">    }</a>
<span class="sourceLineNo">643</span><a id="line.643"></a>
<span class="sourceLineNo">644</span><a id="line.644">    /**</a>
<span class="sourceLineNo">645</span><a id="line.645">     * Removes leading and trailing spaces if any, then the prefix and the suffix in the given name.</a>
<span class="sourceLineNo">646</span><a id="line.646">     * The prefix is anything before the first {@value #PREFIX_SEPARATOR} character.</a>
<span class="sourceLineNo">647</span><a id="line.647">     * The suffix must be the given string, otherwise an exception is thrown.</a>
<span class="sourceLineNo">648</span><a id="line.648">     *</a>
<span class="sourceLineNo">649</span><a id="line.649">     * @param  name     the name from which to remove prefix and suffix.</a>
<span class="sourceLineNo">650</span><a id="line.650">     * @param  suffix   the suffix to remove.</a>
<span class="sourceLineNo">651</span><a id="line.651">     * @return the given name without prefix and suffix.</a>
<span class="sourceLineNo">652</span><a id="line.652">     * @throws SchemaException if the given name does not end with the given suffix.</a>
<span class="sourceLineNo">653</span><a id="line.653">     */</a>
<span class="sourceLineNo">654</span><a id="line.654">    private static String trim(String name, final String suffix) throws SchemaException {</a>
<span class="sourceLineNo">655</span><a id="line.655">        name = name.trim();</a>
<span class="sourceLineNo">656</span><a id="line.656">        if (name.endsWith(suffix)) {</a>
<span class="sourceLineNo">657</span><a id="line.657">            return name.substring(name.indexOf(PREFIX_SEPARATOR) + 1, name.length() - suffix.length());</a>
<span class="sourceLineNo">658</span><a id="line.658">        }</a>
<span class="sourceLineNo">659</span><a id="line.659">        throw new SchemaException(String.format("Expected a name ending with \"%s\" but got \"%s\".", suffix, name));</a>
<span class="sourceLineNo">660</span><a id="line.660">    }</a>
<span class="sourceLineNo">661</span><a id="line.661"></a>
<span class="sourceLineNo">662</span><a id="line.662">    /**</a>
<span class="sourceLineNo">663</span><a id="line.663">     * Returns the attribute of the given name in the given node,</a>
<span class="sourceLineNo">664</span><a id="line.664">     * or throws an exception if the attribute is not present.</a>
<span class="sourceLineNo">665</span><a id="line.665">     */</a>
<span class="sourceLineNo">666</span><a id="line.666">    private static String getMandatoryAttribute(final Node node, final String name) throws SchemaException {</a>
<span class="sourceLineNo">667</span><a id="line.667">        final NamedNodeMap attributes = node.getAttributes();</a>
<span class="sourceLineNo">668</span><a id="line.668">        if (attributes != null) {</a>
<span class="sourceLineNo">669</span><a id="line.669">            final Node attr = attributes.getNamedItem(name);</a>
<span class="sourceLineNo">670</span><a id="line.670">            if (attr != null) {</a>
<span class="sourceLineNo">671</span><a id="line.671">                final String value = attr.getNodeValue();</a>
<span class="sourceLineNo">672</span><a id="line.672">                if (value != null) {</a>
<span class="sourceLineNo">673</span><a id="line.673">                    return value;</a>
<span class="sourceLineNo">674</span><a id="line.674">                }</a>
<span class="sourceLineNo">675</span><a id="line.675">            }</a>
<span class="sourceLineNo">676</span><a id="line.676">        }</a>
<span class="sourceLineNo">677</span><a id="line.677">        throw new SchemaException(String.format("Node \"%s\" should have a '%s' attribute.", node.getNodeName(), name));</a>
<span class="sourceLineNo">678</span><a id="line.678">    }</a>
<span class="sourceLineNo">679</span><a id="line.679"></a>
<span class="sourceLineNo">680</span><a id="line.680">    /**</a>
<span class="sourceLineNo">681</span><a id="line.681">     * Returns the type definitions for a class of the given name.</a>
<span class="sourceLineNo">682</span><a id="line.682">     * Keys are property names and values are their types, with {@code "_PropertyType"} suffix omitted.</a>
<span class="sourceLineNo">683</span><a id="line.683">     * The map contains an entry associated to the {@code null} key for the class containing those properties.</a>
<span class="sourceLineNo">684</span><a id="line.684">     *</a>
<span class="sourceLineNo">685</span><a id="line.685">     * &lt;p&gt;The given {@code typeName} shall be the XML name, not the OGC/ISO name. They differ for abstract classes.</a>
<span class="sourceLineNo">686</span><a id="line.686">     * For example the {@link org.opengis.metadata.citation.Party} type is named {@code "CI_Party"} is OGC/ISO models</a>
<span class="sourceLineNo">687</span><a id="line.687">     * but {@code "AbstractCI_Party"} in XML schemas.&lt;/p&gt;</a>
<span class="sourceLineNo">688</span><a id="line.688">     *</a>
<span class="sourceLineNo">689</span><a id="line.689">     * @param  typeName  XML name of a type (e.g. {@code "MD_Metadata"}), or {@code null}.</a>
<span class="sourceLineNo">690</span><a id="line.690">     * @return all properties for the given class in declaration order, or {@code null} if unknown.</a>
<span class="sourceLineNo">691</span><a id="line.691">     */</a>
<span class="sourceLineNo">692</span><a id="line.692">    public Map&lt;String,Element&gt; getTypeDefinition(final String typeName) {</a>
<span class="sourceLineNo">693</span><a id="line.693">        return typeDefinitions.get(typeName);</a>
<span class="sourceLineNo">694</span><a id="line.694">    }</a>
<span class="sourceLineNo">695</span><a id="line.695"></a>
<span class="sourceLineNo">696</span><a id="line.696">    /**</a>
<span class="sourceLineNo">697</span><a id="line.697">     * Returns the type definitions for the given class. This convenience method computes a XML name from</a>
<span class="sourceLineNo">698</span><a id="line.698">     * the annotations attached to the given type, then delegates to {@link #getTypeDefinition(String)}.</a>
<span class="sourceLineNo">699</span><a id="line.699">     *</a>
<span class="sourceLineNo">700</span><a id="line.700">     * @param  type  the GeoAPI interface (e.g. {@link org.opengis.metadata.Metadata}), or {@code null}.</a>
<span class="sourceLineNo">701</span><a id="line.701">     * @return all properties for the given class in declaration order, or {@code null} if unknown.</a>
<span class="sourceLineNo">702</span><a id="line.702">     */</a>
<span class="sourceLineNo">703</span><a id="line.703">    public Map&lt;String,Element&gt; getTypeDefinition(final Class&lt;?&gt; type) {</a>
<span class="sourceLineNo">704</span><a id="line.704">        if (type != null) {</a>
<span class="sourceLineNo">705</span><a id="line.705">            final UML uml = type.getAnnotation(UML.class);</a>
<span class="sourceLineNo">706</span><a id="line.706">            if (uml != null) {</a>
<span class="sourceLineNo">707</span><a id="line.707">                final Classifier c = type.getAnnotation(Classifier.class);</a>
<span class="sourceLineNo">708</span><a id="line.708">                boolean applySpellingChange = false;</a>
<span class="sourceLineNo">709</span><a id="line.709">                do {                                                // Will be executed 1 or 2 times only.</a>
<span class="sourceLineNo">710</span><a id="line.710">                    String name = uml.identifier();</a>
<span class="sourceLineNo">711</span><a id="line.711">                    if (applySpellingChange) {</a>
<span class="sourceLineNo">712</span><a id="line.712">                        name = departures.spellingChanges.get(name);</a>
<span class="sourceLineNo">713</span><a id="line.713">                        if (name == null) break;</a>
<span class="sourceLineNo">714</span><a id="line.714">                    }</a>
<span class="sourceLineNo">715</span><a id="line.715">                    if (c != null &amp;&amp; Stereotype.ABSTRACT.equals(c.value())) {</a>
<span class="sourceLineNo">716</span><a id="line.716">                        name = "Abstract" + name;</a>
<span class="sourceLineNo">717</span><a id="line.717">                    }</a>
<span class="sourceLineNo">718</span><a id="line.718">                    Map&lt;String,Element&gt; def = getTypeDefinition(name);</a>
<span class="sourceLineNo">719</span><a id="line.719">                    if (def != null) return def;</a>
<span class="sourceLineNo">720</span><a id="line.720">                } while ((applySpellingChange = !applySpellingChange));</a>
<span class="sourceLineNo">721</span><a id="line.721">            }</a>
<span class="sourceLineNo">722</span><a id="line.722">        }</a>
<span class="sourceLineNo">723</span><a id="line.723">        return null;</a>
<span class="sourceLineNo">724</span><a id="line.724">    }</a>
<span class="sourceLineNo">725</span><a id="line.725"></a>
<span class="sourceLineNo">726</span><a id="line.726">    /**</a>
<span class="sourceLineNo">727</span><a id="line.727">     * Prints the given message to standard output stream.</a>
<span class="sourceLineNo">728</span><a id="line.728">     * This method is used instead of logging for reporting downloading of schemas.</a>
<span class="sourceLineNo">729</span><a id="line.729">     *</a>
<span class="sourceLineNo">730</span><a id="line.730">     * @param  message  the message to print.</a>
<span class="sourceLineNo">731</span><a id="line.731">     */</a>
<span class="sourceLineNo">732</span><a id="line.732">    @SuppressWarnings("UseOfSystemOutOrSystemErr")</a>
<span class="sourceLineNo">733</span><a id="line.733">    private static void info(final String message) {</a>
<span class="sourceLineNo">734</span><a id="line.734">        System.out.println("[GeoAPI] " + message);</a>
<span class="sourceLineNo">735</span><a id="line.735">    }</a>
<span class="sourceLineNo">736</span><a id="line.736">}</a>




























































</pre>
</div>
</main>
</body>
</html>
